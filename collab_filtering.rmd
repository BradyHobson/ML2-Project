---
title: "ML2 Final Project - Collaborative Filtering"
author: "Brady Hobson, Sara Kent"
date: "2025-04-14"
output:
  html_document: default
  pdf_document: default
---


```{r}
lmp_df <- read.csv("lmp_data.csv", row.names = 1)
head(lmp_df)
```

# Collab Filtering
For the timestamp we are predicting, we will not have the LMP or the load (aka demand) because the timestamp “hasn’t happened yet”
So, impute the load with the load forecast
Then find similarity scores between the timestamp we are forecasting and all the other timestamps
Take the k most similar (we can experiment with this)
Weighted avg to predict the LMP

```{r}

# function for similarity score calculations
similarity_score <- function(x, y, method) {
  if (method == 'cosine'){
    return(sum(x * y) / (sqrt(sum(x^2)) * sqrt(sum(y^2))))
  }
  else if (method == 'L2'){
    # check this is right 
    return(sqrt(sum((x-y)^2)))
  }
  else {
    return('invalid similarity score metric')
  }
}
```

test_df will have the demand forecast & no LMP
train_df will have the historical lmps and the historical demand
```{r}
collab_filter <- function(train_df, test_df, k, sim_score) {

  # remove LMP for similarity score calculation since the rows to forecast will not have LMPs
  train_features <- subset(train_df, select=-LMP)
  test_features <- subset(test_df, select=-LMP)
  # calculate similarity scores between the "training and test df"-> probably rename those for clarity
  train_df$similarity <- apply(train_features, 1, function(row) {
    sim_score(as.numeric(row), as.numeric(test_features), sim_score)
  })

  # todo: min-max scale and take inverse of L2 norm

  # todo: get top k

  # todo: find & return weighted avgs
}
```


